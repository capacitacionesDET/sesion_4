<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Capacitaci√≥n en R</title>
    <meta charset="utf-8" />
    <meta name="author" content="" />
    <meta name="date" content="2020-12-17" />
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">


class: center, middle

.linea-superior[]
.linea-inferior[]


&lt;img src="imagenes/logo_portada2.png" width="200" /&gt;


## Capacitaci√≥n en R

## Procesamiento de bases de datos (3)

### Diciembre 2020





---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Sesi√≥n 4: Procesamiento de BBDD (3)

--
&lt;br/&gt;

- .medium-par[Uni√≥n de bases de datos (joins, binds)üìå]
&lt;br/&gt;
&lt;br/&gt;

--

- .medium-par[Manejo de variables de tiempo (fechas) üìÜ]
&lt;br/&gt;
&lt;br/&gt;


---

background-image: url(https://media.giphy.com/media/d6igLr7klmdCU/giphy.gif)
background-size: cover
class: center, up, inverse

&lt;br/&gt;
# Uni√≥n de *data frames*

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Uni√≥n de *data frames*

--

&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;

.center[.big-par[¬øPara qu√© tareas creen que es .big-par-red[√∫til] conocer sobre uniones de bases de datos?]]

--

.center[.big-par[ü§î]]


---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Uni√≥n de *data frames*

--

&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
.center[.big-par[¬øAlguna vez han tenido que unir bases de datos?]]

--

.center[.medium-par[¬øO en su .pur[vida cotidiana], han notado que en diversas situaciones ocurren uniones de bases de datos?]]

--

.center[.big-par[ü§î]]


---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Uni√≥n de *data frames*

--
&lt;br/&gt;
&lt;br/&gt;
La mayor√≠a de las funciones para .pur[an√°lisis] y .pur[transformaci√≥n] de datos que utilizaremos en este curso est√°n dise√±adas para operar sobre una tabla o *data frame*.

--

`R` incluye en sus paquetes base una funci√≥n multiprop√≥sito para unir datos llamada `merge()`, adem√°s de `cbind()` y `rbind()`

--

.pur[Si bien no es lo ideal utilizar estas funciones, las revisaremos por su sencillez y por su car√°cter introductorio.]


Posteriormente nos enfocaremos en algunas funciones de `dplyr` que tienen el mismo objetivo que `merge()`, `cbind()` y `rbind()`.

--

Estos son los `joins` de `dplyr`, que ofrecen m√°s control sobre el proceso, dado que existen distintas funciones para generar uniones *ad hoc* a nuestros requerimientos.


---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Uni√≥n de *data frames*

--


.medium-par[No queremos que nos vaya a pasar...]


.pull-left[
![](https://media.giphy.com/media/cFkiFMDg3iFoI/giphy.gif)

]

--

.pull-right[

.medium-par[O esto...]

![](https://media0.giphy.com/media/P4TqKx6NHyLnO/giphy.gif?cid=3640f6095c91abd67a467174592b5512)

]



---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Uni√≥n de *data frames* con *r base*

--

`cbind` o `rbind()` combina una secuencia de argumentos de un vector, una matriz o una data frame, por columnas o por filas.

--

Para que funcione combinar por columnas, las data frame deben tener el mismo n√∫mero de filas.

--

![](imagenes/cbind.png)


---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Uni√≥n de *data frames* con *r base*

Para que funcione combinar por filas, las data frame deben tener el mismo n√∫mero y nombre de columnas.

--

![](imagenes/rbind.png)

--

Para realizar estas combinaciones no se requieren variables llaves.

--

Las funciones tienen limitaciones. Si no coinciden las dimensiones de los objetos a combinar tendremos problemas. 


---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Uni√≥n de *data frames* con *r base*

--

Creemos una base con los asistentes y relatores del curso a partir de tres data:

```r
library(tidyverse)
```

--


```r
det_asistentes &lt;- tibble(nombres = c("Diana", "Pablo", "Rodrigo", "Pamela",
                               "Aylin", "Magdalena", "Vicente", "Georgina",
                               "Randy", "David", "Loreto", "Carla", "Oscar",
                               "Francisco","Daniel","Joaqu√≠n"),
                         sub = c("SECS","SEIT","SECS","SECS","SECS","SECS","SEIT",
                                 "SECS","SECS","No aplica","SEIT","SEET","SEET","SEIT","SEET",
                                 "SEIT"))

tareas_asistentes &lt;- tibble(E1	=c(1,	1	,1	,1	,0	,1	,0	,0	,1	,1,	0	,0	,1	,0	,0,	1),
                            E2	=c(1,	1	,1	,0	,1	,1	,0	,0	,1	,0,	0	,0	,0	,1	,0,	0),
                            E3	=c(0,	0	,0	,0	,1	,0	,0	,0	,1	,0,	0	,0	,0	,0	,0,	0))

relatores&lt;- tibble(nombres = c("Nicol√°s","Gonzalo"),
                   sub=c("SEIT","SEIT"),
                   E1=85,
                   E2=85,
                   E3=85)
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Uni√≥n de *data frames* con *r base*

--


```r
head(det_asistentes,4)
```

```
## # A tibble: 4 x 2
##   nombres sub  
##   &lt;chr&gt;   &lt;chr&gt;
## 1 Diana   SECS 
## 2 Pablo   SEIT 
## 3 Rodrigo SECS 
## 4 Pamela  SECS
```

```r
head(tareas_asistentes,3)
```

```
## # A tibble: 3 x 3
##      E1    E2    E3
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1     1     1     0
## 2     1     1     0
## 3     1     1     0
```

```r
head(relatores)
```

```
## # A tibble: 2 x 5
##   nombres sub      E1    E2    E3
##   &lt;chr&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 Nicol√°s SEIT     85    85    85
## 2 Gonzalo SEIT     85    85    85
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Uni√≥n de *data frames* con *r base*


```r
det&lt;-cbind(det_asistentes,tareas_asistentes)
head(det,4)
```

```
##   nombres  sub E1 E2 E3
## 1   Diana SECS  1  1  0
## 2   Pablo SEIT  1  1  0
## 3 Rodrigo SECS  1  1  0
## 4  Pamela SECS  1  0  0
```

```r
dim(det)
```

```
## [1] 16  5
```

--

¬°Funcion√≥ pegar las columnas de las dos bases!

--

¬øC√≥mo combinar la base de los asistentes con los de los relatores?

--


```r
det&lt;-rbind(det,relatores)
dim(det)
```

```
## [1] 18  5
```



---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Uni√≥n de *data frames* con *r base*

--

Complejizemos las combinaciones de bases de datos...

--

Carguemos ahora la base `guaguas`. Creemos una base anidada por nombres.

--


```r
library(guaguas)
guaguas_n&lt;-guaguas %&gt;% group_by(nombre) %&gt;% summarise(total=sum(n)) %&gt;% as.data.frame()
guaguas_sexo&lt;-guaguas %&gt;% group_by(nombre) %&gt;% slice(1) %&gt;% select(nombre,sexo) %&gt;% as.data.frame()

head(guaguas_n,3)
```

```
##   nombre total
## 1  Aaron  6281
## 2  Aar√≥n  1673
## 3   Abby   313
```

```r
head(guaguas_sexo,3)
```

```
##   nombre sexo
## 1  Aaron    M
## 2  Aar√≥n    M
## 3   Abby    F
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Uni√≥n de *data frames* con *r base*

--

Veamos las dimensiones de las dos bases

--


```r
dim(guaguas_n)
```

```
## [1] 2871    2
```

```r
dim(guaguas_sexo)
```

```
## [1] 2871    2
```

--

Se pueden combinar f√°cilmente... ¬øo no? 


```r
guaguas_agrup&lt;-cbind(guaguas_sexo,guaguas_n)
head(guaguas_agrup,4)
```

```
##   nombre sexo nombre total
## 1  Aaron    M  Aaron  6281
## 2  Aar√≥n    M  Aar√≥n  1673
## 3   Abby    F   Abby   313
## 4 Abdiel    M Abdiel   519
```
--

El nombre est√° repetido...

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Uni√≥n de *data frames* con *r base*

--

Una forma de solucionarlo es considerando a `nombre` como una variable llave.

--

La funci√≥n `merge()` nos permitir√° solucionar esto. 

--

Adem√°s, la funci√≥n merge nos permitir√° combinar bases de datos con distintas dimensiones.

--

**¬øComo funciona?**

En su forma m√°s simple: `merge(x , y , by= "llave")`

.pur[De esta forma solo se conservan aquellas filas que hacen *match*]

--

As√≠ se conservan todas las filas: `merge(x , y , by= "llave", all=TRUE)`

--

y as√≠ la base que nosotros/as elijamos: 


`merge(x , y , by= "llave", all.x=TRUE)` .

--

o 

--

`merge(x , y , by= "llave", all.y=TRUE)`.

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Uni√≥n de *data frames* con *r base*

--




--

¬øComo saber cu√°l nombre de los asistentes y relatores del curso es el con m√°s inscripciones seg√∫n el registro de `guaguas`?

--


```r
names(det)
```

```
## [1] "nombres" "sub"     "E1"      "E2"      "E3"
```

```r
names(guaguas_n)
```

```
## [1] "nombre" "total"
```

--

La variable `nombre` que usaremos como "llave" **no** tiene el mismo nombre en las bases.

--


```r
det&lt;-det %&gt;% rename(nombre=nombres)
```

--


```r
det&lt;-merge(det,guaguas_n,by="nombre",all.x = TRUE)

det %&gt;% arrange(desc(total)) %&gt;% head(3)
```

```
##      nombre  sub E1 E2 E3  total
## 1 Francisco SEIT  0  1  0 181425
## 2   Rodrigo SECS  1  1  0 123344
## 3    Daniel SEET  0  0  0 108879
```



---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Uni√≥n de *data frames* con *r base*

Distintas formas para combinar muchas bases de datos a la vez (les servir√° a futuro):

--

Sin llave: `Reduce(function(x, y) merge(x, y, all=TRUE), list(df1, df2, df3))`

--

Con llave: `Reduce(function(x,y) merge(x, y, by = "key"), list(df1,df2,df3))`

--

Ahora vamos con `dplyr`...



---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Familia Join

--

Como .pur[intuici√≥n b√°sica], los joins .medium-par-red[combinan] dos data frames agregando columnas de uno al otro.

--

Si bien existen **6 tipos de joins b√°sicos**, nos concentraremos ac√° en los **2 que m√°s se utilizan**.

--

- `left_join()`
- `inner_join()`

--

Que son 2 de los 4 joins denominados como .pur[*mutating*] joins.

--

Y tambi√©n veremos 2 funciones muy sencillas de .pur[ensamblaje] de *data frames* con `dplyr`.

- `bind_rows()` (su simil en lenguaje R base es `rbind()`)
- `bind_cols()` (su simil en lenguaje R base es `cbind()`)

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Familia Join

--

Entonces, .pur[a modo de contexto], veamos los tipos de `joins` que existen.

--

.center[
&lt;img src="imagenes/join_dplyr.PNG" width="400" /&gt;
]

--

Como pueden ver, **son bastantes** (y no est√°n todos ah√≠ üò±ü§Ø ). Esto es porque son .pur[muy espec√≠ficos].

--

Poder usar cada uno de forma precisa es todo un arte üé®üñå.

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Tipos de uniones (no solo joins) 

--

Hay .pur[diferentes tipos de uniones] de *data frames*:

.pull-left[

.pur[*Mutating joins:*] para agregar columnas.

- `left_join()`
- `right_join()`
- `inner_join()`
- `full_join()`

&lt;br/&gt;
.pur[*Joins de filtrado:*] para extraer o filtrar filas.

- `semi_join()`
- `anti_join()`

.pur[*funciones de ensamblaje:*] para "pegar" *data frames*

- `bind_rows()`
- `bind_cols()`
]

.pull-right[
&lt;img src="imagenes/filter_mut.PNG" width="200" /&gt;
]

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# dplyr::left_join()

--

Es la funci√≥n de uni√≥n m√°s b√°sica y .medium-par-red[m√°s utilizada] entre los `joins`.

--

¬øQu√© hace `left_join()`?

--

(En adelante, llamaremos al primer *data frame* .medium-par[X] y al segundo .medium-par[Y])

--

- Retorna **todas las filas de X** y .pur[todas las columnas de X e Y].

--

- Las filas de X que no tienen *match* en Y, tendr√°n `NAs` en las nuevas variables.

--

- Las filas de Y que no tienen *match* en X, **son ignoradas por completo**.

--

.center[
&lt;img src="imagenes/left_join.PNG" width="650" /&gt;
]

--

.medium-par[`right_join()` hace exactamente lo mismo pero al rev√©s.] 

--

.medium-par[Veamos un ejemplo...]

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# dplyr::left_join()

.pull-left[

```r
library(dplyr)
band_members
```

```
## # A tibble: 3 x 2
##   name  band   
##   &lt;chr&gt; &lt;chr&gt;  
## 1 Mick  Stones 
## 2 John  Beatles
## 3 Paul  Beatles
```
]

--

.pull-right[

```r
band_instruments
```

```
## # A tibble: 3 x 2
##   name  plays 
##   &lt;chr&gt; &lt;chr&gt; 
## 1 John  guitar
## 2 Paul  bass  
## 3 Keith guitar
```
]

--


```r
left_join(band_members, band_instruments, by = "name")
```

```
## # A tibble: 3 x 3
##   name  band    plays 
##   &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt; 
## 1 Mick  Stones  &lt;NA&gt;  
## 2 John  Beatles guitar
## 3 Paul  Beatles bass
```

--

Se puede hacer lo mismo con *pipes*.


```r
band_members %&gt;% left_join(band_instruments, by = "name")
```

--

.pur[¬øCu√°l es la llave o *key* que conecta los dos *data frames*?]

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%


# Sobre las llaves (*keys*)

--

Aunque en problemas de pocas variables no es necesario indicarla (podr√≠amos no haber escrito `by = "name"`).

--

La llave en general es muy importante, y sirve para .pur[individualizar sin ambiguedades] a cada observaci√≥n.

--

Es por eso que puede estar compuesta por una, dos, o m√°s variables si es necesario.

--

.pull-left[
&lt;img src="imagenes/llave_unica.PNG" width="400" /&gt;
]

--

.pull-right[
&lt;img src="imagenes/llave_doble.PNG" width="400" /&gt;
]

--

.center[**base X:** *primary key* / **base Y:** *foreign key*.]

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# dplyr::inner_join()

--

.medium-par[Retorna **SOLO las filas de X donde hay *match* con Y** y todas las columnas de X e Y.]

--

Las filas de X que no tienen *match* en Y, .pur[son ignoradas por completo].

--

Las filas de Y que no tienen *match* en X, .pur[son ignoradas por completo].

--

.medium-par[Esta funci√≥n generalmente reduce filas de un *data frame*.]

--

.center[
&lt;img src="imagenes/inner_join.PNG" width="650" /&gt;
]

--

.medium-par[Veamos un ejemplo...]

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# dplyr::inner_join()

--

Tomemos este c√≥digo y creemos `songs` y `albums`.


```r
songs &lt;- tibble(song = c("Come Together", "Dream On", "Hello,Goodbye", "It's Not Unusual"),
                album  = c("Abbey Road", "Aerosmith", "Magical Mystery Tour", "Along Came Jones"),
                first = c("John", "Steven", "Paul", "Tom"),
                last = c("Lennon", "Tyler", "McCartney", "Jones"))

albums &lt;- tibble( album = c("A Hard Day's Night", "Magical Mystery Tour", "Beggar's Banquet",
                            "Abbey Road", "Led Zeppelin IV", "The Dark Side of the Moon",
                            "Aerosmith", "Rumours", "Hotel California"),
                  band = c("The Beatles", "The Beatles", "The Rolling Stones",
                           "The Beatles", "Led Zeppelin", "Pink Floyd", "Aerosmith",
                           "Fleetwood Mac", "Eagles"),
                  year = c(1964,1967,1968,1969,1971,1973,1973,1977,1982))
```

--

.medium-par[¬øCu√°l es la posible llave entre estos dos *data frames*? ü§®]

--

¬øQu√© pasar√° si hacemos un `inner_join()` sin especificar una llave?

--

Vamos a ver...

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# dplyr::inner_join()



```r
songs %&gt;% inner_join(albums)
```

```
## Joining, by = "album"
```

```
## # A tibble: 3 x 6
##   song          album                first  last      band         year
##   &lt;chr&gt;         &lt;chr&gt;                &lt;chr&gt;  &lt;chr&gt;     &lt;chr&gt;       &lt;dbl&gt;
## 1 Come Together Abbey Road           John   Lennon    The Beatles  1969
## 2 Dream On      Aerosmith            Steven Tyler     Aerosmith    1973
## 3 Hello,Goodbye Magical Mystery Tour Paul   McCartney The Beatles  1967
```

--

En este caso **no hay ambig√ºedad**, por lo que R entiende cu√°l es la llave.

--

Puedo restringir la cantidad de columnas que quiero unir de cualquiera de los dos *data frames*.

--


```r
songs[c(1,2)] %&gt;% inner_join(albums[-3], by = "album")
```

```
## # A tibble: 3 x 3
##   song          album                band       
##   &lt;chr&gt;         &lt;chr&gt;                &lt;chr&gt;      
## 1 Come Together Abbey Road           The Beatles
## 2 Dream On      Aerosmith            Aerosmith  
## 3 Hello,Goodbye Magical Mystery Tour The Beatles
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# dplyr::inner_join()

Como pueden notar, la dificultad de los `joins` no est√° en el c√≥digo.

--

.medium-par[Se encuentra en decidir c√≥mo, cu√°ndo y cu√°l usar.]

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Mini-ejercicio 1 

## Ahora ustedes...

--

Creemos estas dos *tibbles* de `artists` y `bands`.


```r
artists &lt;- tibble(first = c("Jimmy", "George", "Mick", "Tom", "Davy", 
                            "John", "Paul", "Jimmy", "Joe", "Elvis", "Keith",
                            "Paul", "Ringo", "Joe", "Brian", "Nancy"),
                  last = c("Buffett", "Harrison", "Jagger", "Jones", "Jones",
                            "Lennon", "McCartney", "Page", "Perry", "Presley", 
                           "Richards", "Simon", "Starr", "Walsh", "Wilson", "Wilson"),
                  instrument = c("Guitar", "Guitar", "Vocals", "Vocals", "Vocals", 
                                 "Guitar", "Bass", "Guitar", "Guitar", "Vocals",
                                  "Guitar", "Guitar", "Drums", "Guitar", "Vocals", "Vocals"))

bands &lt;- tibble(first = c("John", "John Paul", "Jimmy", "Robert", "George", "John", 
                          "Paul", "Ringo", "Jimmy", "Mick", "Keith",  "Charlie", "Ronnie"),
                last = c("Bonham", "Jones", "Page", "Plant", "Harrison", "Lennon", "McCartney",
                         "Starr", "Buffett", "Jagger", "Richards", "Watts", "Wood"), 
                band = c("Led Zeppelin", "Led Zeppelin", "Led Zeppelin", "Led Zeppelin", 
                         "The Beatles", "The Beatles", "The Beatles", "The Beatles", 
                         "The Coral Reefers", "The Rolling Stones", "The Rolling Stones", 
                         "The Rolling Stones", "The Rolling Stones"))
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Mini-ejercicio 1 

--

Utilizando las bases `artists` y `bands`.

--

1- Generar una base de datos que contenga *first* (nombre), *last* (apellido) y la banda (*band*), para **todos** los artistas presentes en la base `artists`.

--

.medium-par[¬øQu√© pueden observar sobre la base resultante?]

--

2- Generar una base de datos, a partir *artist* y *bands*, que contenga las variables *first* (nombre), *last* (apellido), la banda (*band*) e instrumento (*instrument*), que incluya solo a los artistas que tienen informaci√≥n en las 4 variables.

--

.medium-par[¬øCu√°ntas observaciones tiene la base creada?]


---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Mini-ejercicio 1: soluci√≥n

--

**Ejercicio 1:**


```r
artists %&gt;% left_join(bands, by = c("first", "last")) %&gt;% head()
```

```
## # A tibble: 6 x 4
##   first  last     instrument band              
##   &lt;chr&gt;  &lt;chr&gt;    &lt;chr&gt;      &lt;chr&gt;             
## 1 Jimmy  Buffett  Guitar     The Coral Reefers 
## 2 George Harrison Guitar     The Beatles       
## 3 Mick   Jagger   Vocals     The Rolling Stones
## 4 Tom    Jones    Vocals     &lt;NA&gt;              
## 5 Davy   Jones    Vocals     &lt;NA&gt;              
## 6 John   Lennon   Guitar     The Beatles
```

--

**Ejercicio 2:**


```r
artists %&gt;% inner_join(bands, by = c("first", "last")) %&gt;% head(5)
```

```
## # A tibble: 5 x 4
##   first  last      instrument band              
##   &lt;chr&gt;  &lt;chr&gt;     &lt;chr&gt;      &lt;chr&gt;             
## 1 Jimmy  Buffett   Guitar     The Coral Reefers 
## 2 George Harrison  Guitar     The Beatles       
## 3 Mick   Jagger    Vocals     The Rolling Stones
## 4 John   Lennon    Guitar     The Beatles       
## 5 Paul   McCartney Bass       The Beatles
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Funciones de ensamblaje 

--

hasta ahora no se ha mencionado la forma m√°s sencilla de unir 2 *data frames*.

--

Si tenemos dos *data frames* que tienen la misma estructura de columnas o de filas...

--

**Por ejemplo:** submuestras de una encuesta, distintos a√±os de un RRAA, etc.

--

Podemos simplemente .medium-par-red[ensamblarlas.]

--

`R` base trae por defecto `rbind()` para pegar filas y `cbind()` para columnas.

--

Recomendamos usar `bind_rows()` y `bind_cols()` de `dplyr()`.

--

**Importante:** `cbind`, pero tambi√©n `bind_cols()` no usan una llave, **suponen que las filas est√°n en el mismo orden**.

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# bind_rows() y bind_cols()

--

¬øpor qu√© preferir `bind_rows()` y `bind_cols()` en vez de `rbind()` y `cbind()`?

--

- Son m√°s r√°pidas

--

- Siempre retornan una `tibble`, que es una versi√≥n mejorada de un *data frame*.

--

- Tienen una sintaxis m√°s flexible.

--

- **Y lo m√°s importante:** el argumento ".id" de `bind_rows()`, permite identificar el origen de cada fila. Esto hace m√°s f√°cil su tratamiento.

--

Generemos un ejemplo de juguete solo para ejemplificar el uso de `bind_rows`.

--


```r
artists_2 = artists #duplicamos este data frame solo con un fin pedag√≥gico

ensamble &lt;- bind_rows(original = artists, duplic = artists_2, .id= "base_datos")
```

---

background-image: url(https://media2.giphy.com/media/xsF1FSDbjguis/200w.webp?cid=3640f6095c9321d95239485951223fbe)
background-size: cover
class: center, bottom, inverse

# Variables de tiempo en R

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Variables de tiempo en R

--

Las .medium-par[fechas y horas ‚è≥], como informaci√≥n, presentan una **gran versatilidad **para el an√°lisis de diversos fen√≥menos.

--

En este m√≥dulo **solo veremos fechas** üìÜ, pero para horas, minutos y segundos la l√≥gica es la misma.

--

Sin embargo, si bien es posible trabajar variables de tiempo sin herramientas dedicadas, ser√≠a **extremadamente engorroso**, y se requerir√≠an .pur[herramientas medianamente sofisticadas] para transformar estas variables en objetos con los que podamos operar.

--

Para eso `R` ofrece herramientas dedicadas especialmente a solucionarnos la vida. Podr√≠an separarse en 2 tipos:

--

- Herramientas para .pur[organizar fechas en un formato reconocible].

- Herramientas que .pur[traduzcan] estas fechas de formato estandarizado a .medium-par-red[n√∫meros].

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Variables de tiempo en R


Y con n√∫meros se pueden hacer muchas cosas: **operaciones matem√°ticas**, **gr√°ficos**, etc. Mientras `R` por detr√°s trabaja con n√∫meros, nosotros seguimos viendo sencillas y amigables fechas üôÉ.

--


```r
# Pueden reemplazar esta fecha por sus cumplea√±os
mi_cumple &lt;- ("1993-09-30")
str(mi_cumple)
```

```
##  chr "1993-09-30"
```

--


```r
mi_cumple &lt;- as.Date(mi_cumple)
str(mi_cumple)
```

```
##  Date[1:1], format: "1993-09-30"
```

--


```r
as.numeric(mi_cumple)
```

```
## [1] 8673
```

--

La funci√≥n `as.Date()` recibi√≥ una cadena de caracteres y la transform√≥ en un objeto fecha (`date`), y esa fecha aloja un n√∫mero. .medium-par-red[¬øQu√© representa ese n√∫mero?]

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Variables de tiempo en R


```r
as.numeric(as.Date("1970-01-01"))
```

```
## [1] 0
```

--

Es la distancia desde un momento **escogido de manera arbitraria**: el .medium-par-red[1 de enero de 1970].

--

`as.Date()` es una funci√≥n sencilla de usar, **pero no es muy robusta para el trabajo con fechas**.

--


```r
mi_cumple &lt;- as.Date("30-09-1993"); str(mi_cumple) 
```

```
##  Date[1:1], format: "0030-09-19"
```

--

.pur[No soluciona el problema del ordenamiento]. Requiere asistentes para hacerlo. 


---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Variables de tiempo en R

--

A√∫n as√≠, **no hay que descartarla**, es muy √∫til cuando el formato es la norma ISO 8661. Esta indica un formato .medium-par-red[YYYY-MM-DD] y una cantidad de d√≠gitos por par√°metro (4-2-2).

--

Dentro del universo de `tidyverse` existe una **librer√≠a especializada para el tratamiento de fechas y horas**.

--

Se llama `lubridate` y su objetivo es hacer m√°s intuitiva la manipulaci√≥n y an√°lisis de este tipo de variables.

--

Veamos algunos operadores b√°sicos muy √∫tiles.

--

`R` base tiene funciones para extraer la fecha y hora en el momento de la consulta.


```r
Sys.Date() # La fecha de hoy
```

```
## [1] "2020-12-17"
```

```r
Sys.time() # el momento exacto, con fecha, horas, minutos y segundos
```

```
## [1] "2020-12-17 12:49:27 -03"
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Manejo de fechas con `lubridate`

--

`lubridate` tiene funciones que hacen lo mismo, pero con un lenguaje m√°s intuitivo.

--


```r
library(lubridate) # cargamos lubridate
```

```
## Warning: package 'lubridate' was built under R version 3.6.3
```

```r
today() 
```

```
## [1] "2020-12-17"
```

```r
now()
```

```
## [1] "2020-12-17 12:49:27 -03"
```

--

**Hay 2 formas principales para crear una fecha.**

--

- Desde una cadena de caracteres o numeros. 

--

- Desde componentes *date-time* individuales.

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Manejo de fechas con `lubridate`

--

.pull-left[

**1. Desde cadenas de caracteres**


- La m√°s habitual es a partir de cadenas de caracteres.

- Existen helpers en `lubridate` que autom√°ticamente ordenan el formato de una variable fecha.

- Solo hay que ordenarlos de acuerdo al input.

- Se aceptan diferentes tipos de separadores.

]

.pull-right[

```r
ymd("1993-09-30")
```

```
## [1] "1993-09-30"
```

```r
## No asimila bien el mes en espa√±ol
mdy("Sep 30, 1993")
```

```
## [1] "1993-09-30"
```

```r
dmy("30/sep/1993")
```

```
## [1] "1993-09-30"
```

]

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Manejo de fechas con `lubridate`

--

Tambi√©n se pueden crear fechas a partir de variables num√©ricas. .medium-par-red[Siempre y cuando respeten el orden y cantidad de d√≠gitos].

--


```r
ymd(20190322)
```

```
## [1] "2019-03-22"
```

```r
dmy(22032019)
```

```
## [1] "2019-03-22"
```

--

**2. Creaci√≥n desde componentes *date-time* individuales**

--

A veces las fechas nos llegan en un *data frame* separadas en d√≠a, mes, a√±o.

---
background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Manejo de fechas con `lubridate`

--

Debemos unirlas para operarlas como objetos *date*. **Usaremos la base de nacimientos de EEVV 2017**.

--

Para crear un objeto `date` que llamaremos `fecha_nac` usamos la funci√≥n `make_date()` de `lubridate`.



```r
# cargamos la base
library(readxl)
```

```
## Warning: package 'readxl' was built under R version 3.6.3
```

```r
library(lubridate)

nac2017 &lt;- read_excel("data/nac_2017.xlsx")

# seleccionamos d√≠a, mes, a√±o de nacimiento y creamos una fecha
nac2017 %&gt;% 
  select(dia_nac, mes_nac, ano_nac) %&gt;% 
  mutate(fecha_nac = make_date(ano_nac, mes_nac, dia_nac)) %&gt;% 
  head(5)
```

```
## # A tibble: 5 x 4
##   dia_nac mes_nac ano_nac fecha_nac 
##     &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;date&gt;    
## 1      27      11    2017 2017-11-27
## 2      27       1    2017 2017-01-27
## 3      21       3    2017 2017-03-21
## 4      28       6    2017 2017-06-28
## 5      10       4    2017 2017-04-10
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Mini-ejercicio 2

--
&lt;br/&gt;
&lt;br/&gt;
Utilizando la base de datos "nac2017" que acabamos de cargar en nuestro entorno de trabajo.

--
&lt;br/&gt;
&lt;br/&gt;
1- Generar dentro de la base de datos (en la misma o un objeto nuevo) una variable llamada "fecha_nac" que contenga en un solo campo la fecha de nacimiento completa de cada nacido.

--
&lt;br/&gt;
&lt;br/&gt;
2- Generar adem√°s una variable llamada "fecha_ins" que contenga en un solo campo la fecha de inscripci√≥n completa de cada nacido.

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Mini-ejercicio 2: soluci√≥n

--

Es posible crear ambas variables en un solo paso.



```r
nac2017 &lt;- nac2017 %&gt;% 
  mutate(fecha_nac = make_date(ano_nac, mes_nac, dia_nac),
         fecha_ins = make_date(ano_ins, mes_ins, dia_ins)) 
```


```r
nac2017 %&gt;% select(ano_nac, mes_nac, dia_nac, ano_ins, mes_ins,
                   dia_ins, fecha_nac, fecha_ins) %&gt;%
  head() 
```

```
## # A tibble: 6 x 8
##   ano_nac mes_nac dia_nac ano_ins mes_ins dia_ins fecha_nac  fecha_ins 
##     &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;date&gt;     &lt;date&gt;    
## 1    2017      11      27    2017      11      30 2017-11-27 2017-11-30
## 2    2017       1      27    2017       2       2 2017-01-27 2017-02-02
## 3    2017       3      21    2017       3      23 2017-03-21 2017-03-23
## 4    2017       6      28    2017       7       3 2017-06-28 2017-07-03
## 5    2017       4      10    2017       4      13 2017-04-10 2017-04-13
## 6    2017      10      14    2017      10      16 2017-10-14 2017-10-16
```



---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Manejo de fechas con `lubridate`

--

As√≠ como podemos componer una fecha, tambi√©n podemos descomponerla.

--


```r
mi_cumple &lt;- dmy("30-09-1993")
year(mi_cumple)
```

```
## [1] 1993
```

--


```r
month(mi_cumple, label = T) # con label se pide la etiqueta
```

```
## [1] sept
## 12 Levels: ene &lt; feb &lt; mar &lt; abr &lt; may &lt; jun &lt; jul &lt; ago &lt; sept &lt; ... &lt; dic
```

--


```r
mday(mi_cumple)
```

```
## [1] 30
```

--


```r
wday(mi_cumple, label = T) # considera que el d√≠a 1 es el domingo
```

```
## [1] jue
## Levels: dom &lt; lun &lt; mar &lt; mi√© &lt; jue &lt; vie &lt; s√°b
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Operaciones aritm√©ticas

--

Por ejemplo, pueden saber .pur[cu√°ntos d√≠as de vida tienen]. 


```r
today() - ymd("1993-09-30") 
```

```
## Time difference of 9940 days
```

--

Existe un **set de funciones** que sirven para operar sobre periodos de tiempo de una manera .pur[intuitiva y versatil]: se llaman `periods` y algunos da ellos son:


```r
days(1)
weeks(1)
months(1) # esta funci√≥n es de R base
years(1)
```

--

¬øQu√© podemos hacer con ellos?


```r
# ¬øque fecha es en un a√±o y un mes m√°s?
today() + years(1) + months(1)
```

```
## [1] "2022-01-17"
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Operaciones aritm√©ticas

--

Podemos, por ejemplo, crear una variable *deadline* que indique cu√°ndo es un mes despu√©s de un punto inicial.


```r
inicio &lt;- as.Date("2020-08-30")
inicio + months(1)
```

```
## [1] "2020-09-30"
```

--

Pero no es una funci√≥n tan robusta. .pur[¬øQu√© pasa con los meses de 31 d√≠as?]

--


```r
inicio &lt;- ymd("2020-08-31") # esta otra funci√≥n es parecida a as.Date
inicio + months(1)
```

```
## [1] NA
```

--

No sabe qu√© hacer y entrega un `NA`. Pero `lubridate()` contiene operadores .pur[robustos] para solucionarlo.

--


```r
inicio %m+% months(1)
```

```
## [1] "2020-09-30"
```


---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Operaciones aritm√©ticas

--

`%m+%` tambi√©n funciona con a√±os y d√≠as. .medium-par[Tambi√©n existe `%m-%` para restar periodos].

--


```r
bisiesto &lt;- ymd("2020-02-29")
bisiesto %m+% years(1)
```

```
## [1] "2021-02-28"
```

--


```r
bisiesto %m+% days(1)
```

```
## [1] "2020-03-01"
```

--

Adem√°s se pueden generar autom√°ticamente varios periodos. .pur[Esto puede ser muy √∫til para validar datos] üëÄ


```r
inicio &lt;- ymd("2020-08-31")
inicio %m+% months(1:6)
```

```
## [1] "2020-09-30" "2020-10-31" "2020-11-30" "2020-12-31" "2021-01-31"
## [6] "2021-02-28"
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Operaciones aritm√©ticas

--

Tambien podemos calcular **intervalos de tiempo** entre dos momentos de manera consistente.

--

Para eso utilizamos el operador .medium-par[`%--%`].

--


```r
siguiente_a√±o &lt;- today() + years(1)
(today() %--% siguiente_a√±o) / days(1) # diferencia en d√≠as
```

```
## [1] 365
```

--

Para encontrar cu√°ntos per√≠odos caen dentro de un intervalo, con `%/%` pueden obtener la divisi√≥n entera:

--


```r
(today() %--% siguiente_a√±o) / weeks(1)
```

```
## [1] 52.14286
```

Ahora con `%/%`.


```r
(today() %--% siguiente_a√±o) %/% weeks(1)
```

```
## [1] 52
```


---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Mini-ejercicio 3

--
&lt;br/&gt;
Vamos a utilizar la base de datos donde creamos "fecha_nac" y "fecha_ins".

--

La variable "fecha_nac" refiere a la .pur[fecha de nacimiento] de un nacido durante el a√±o estad√≠stico 2017 y "fecha_ins" indica la .pur[fecha en que el nacido fue inscrito].

--

1- Genera una variable llamada "dif_days" que indique la **diferencia en d√≠as** entre que los nacidos nacieron y fueron inscritos.

--

2- Genera una variable llamada "dif_weeks" que indique la **diferencia en semanas enteras** (sin decimales) entre que los nacidos nacieron y fueron inscritos.

--

3- Escoje una de las dos variables creadas y **genera una tabla de resumen** que contenga la m√≠nima diferencia, la m√°xima, diferencia media y la mediana.

--

.center[.medium-par[Para resolver el punto 3 usen ` %&gt;% summarise(min(),max(),media(),median())`Ô∏è]]

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Mini-ejercicio 3


1- Generar "dif_days".

--


```r
nac2017 &lt;- nac2017 %&gt;% 
  mutate(dif_days = (fecha_nac %--% fecha_ins) / days(1))
```

--

2- Generar "dif_weeks".


```r
nac2017 &lt;- nac2017 %&gt;% 
  mutate(dif_weeks = (fecha_nac %--% fecha_ins) %/% weeks(1))
```

3- Generaci√≥n tabla de resumen de estad√≠sticos.


```r
resumen_dif &lt;- nac2017 %&gt;% summarise(min_dif = min(dif_days),
                                     max_dif = max(dif_days),
                                     media_dif = mean(dif_days),
                                     median_dif = median(dif_days))
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Manejo de fechas con `lubridate`

--

El uso de `lubridate` puede generar **cierta dificultad** en un principio.

--

Esto debido a la cantidad de operadores nuevos que ofrece (%--%, %m+%, %m-%, etc.).

--

Pero si trabajamos habitualmente con fechas u horas, y son un aspecto importante de nuestro trabajo, vale mucho la pena estudiarlos bien.

--

Pues `lubridate` ofrece herramientas .medium-par-red[precisas] y .medium-par-red[robustas] para el trabajo con datos temporales.

--

.medium-par[Que adem√°s son absolutamente compatibles con las librer√≠as de `tidyverse`].

--

Pueden encontrar much√≠sima m√°s informaci√≥n [aqu√≠](https://lubridate.tidyverse.org/).


---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Tarea para la üè†

--

En el archivo "nacimientos.rar" que se encuentra disponible **[aqu√≠](https://inechile-my.sharepoint.com/:u:/g/personal/nicolas_ratto_ine_cl/EeHIsLYPX7FGjXyLGV6tci8Blar-7Ol1WQ-qcm4ZgtKcEg?e=0jsmRt)**, encontrar√°n las siguientes bases de datos:

--

- **nac2017_j1.xlsx**
- **nac2017_j2.xlsx**
- **nac2017_j3.xlsx**

--

Estas bases de datos .pur[fueron creadas a partir de la base de datos oficial de nacimientos del 2017].

--

1- En primer lugar, **carga estos 3 objetos en su entorno y expl√≥relos**. .pur[¬øQu√© son y c√≥mo se relacionan estos objetos?]

--

2- Genera en **nac2017_j2** y **nac2017_j3** las variables "fecha_nac", "fecha_ins" y "dif_days", tal como lo hiciste en el ejercio anterior.

--

3- Ahora, une **nac2017_j1** con **nac2017_j2**, conservando todos los registros de **nac2017_j1** y solo las variables "fecha_nac", "fecha_ins" y "dif_days" de **nac2017_j2**, que acabas de crear.

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Tarea para la üè†

--

4- .pur[¬øQu√© sucedi√≥ al unir **nac2017_j1** con **nac2017_j2**? ¬øSe unieron todos los registros? Si no lo hicieron, ¬øpor qu√© pas√≥ eso?]

--

5- Ahora .pur[ensambla] **nac2017_j2** y **nac2017_j3** y este nuevo objeto √∫nelo con **nac2017_j1**, conservando solo "fecha_nac", "fecha_ins" y "dif_days" del objeto ensamblado.

--

6- .medium-par-red[¬øQu√© pas√≥ ahora? üôÇ]


---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Referencias

.medium-par[Nada de esto ser√≠a posible sin:]

- [R for Data Science, de Hadley Wickham](https://r4ds.had.co.nz/)

- [Advanced R, de Hadley Wickham](http://adv-r.had.co.nz/Introduction.html)

- [Data wrangling, exploration, and analysis with R, de Jenny Bryan](http://stat545.com/index.html)

- [Introduction to R, de Data Carpentry](https://datacarpentry.org/R-genomics/01-intro-to-R.html#functions)

- [Xaringan: Presentation Ninja, de Yihui Xie](https://github.com/yihui/xaringan). Para generar esta presentaci√≥n con la plantilla ninja ‚öî

- [Tutorial de `lubridate`](https://lubridate.tidyverse.org/)

.medium-par[R for Data Science tiene una traducci√≥n al espa√±ol realizada por la comunidad hispana de R:]

- [R para ciencia de datos, de Hadley Wickham](https://es.r4ds.hadley.nz/)

---

class: center, middle

.linea-superior[]
.linea-inferior[]


&lt;img src="imagenes/logo_portada2.png" width="200" /&gt;


## Capacitaci√≥n en R

## Procesamiento de bases de datos (3)

### Diciembre 2020
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
